COMPRESSION 7

<cmath>
<algorithm>
"PlotTools/interface/KinematicFunctions.h"
"PandaTree/Objects/interface/Event.h"
"misc.h"

{/F}                           ! Default type
{0}                            ! Default value
{reset(panda::Event& event)}   ! Define the arguments of reset

$/i = event.$ | runNumber, lumiNumber
eventNumber/l = event.eventNumber

npv/s = event.npv
npv_true/s = event.npvTrue

mc_weight = event.weight

met = event.pfMet.pt
metphi = event.pfMet.phi
calomet = event.caloMet.pt
calometphi = event.caloMet.phi
trkmet = event.trkMet.pt
trkmetphi = event.trkMet.phi

met_trigger/O = false
met_filter/O = event.metFilters.pass()

{/b}

! Count some objects

n, fake {
  countjets(panda::Jet& jet, float abseta)

    alljet -> ++

    ~~ abseta < 2.5 ~~
    jet -> ++
    min_dphi_metj_soft/F = 4 -> std::min([]_min_dphi_metj_soft, static_cast<Float_t>(deltaPhi(metphi, jet.phi())));

    ~~ jet.pt() > 30.0 ~~
    hardjet -> ++
    min_dphi_metj_hard/F = 4 -> std::min([]_min_dphi_metj_hard, static_cast<Float_t>(deltaPhi(metphi, jet.phi())));

    ~~ abseta < 2.4 ~~
    centerjet -> ++
}

min_dphi_metj_$/F <- n_min_dphi_metj_$ | soft, hard    ! Add this back in just to keep sensible names

n_genB

n_soft {
  , _all {
    softcount(float pt)
      ~~ pt > 2 ~~
      2 -> ++
      ~~ pt > 5 ~~   ! Cuts required to continue
      5 -> ++
      ~~ pt > 10 ~~
      10 -> ++
  }
}

n_bcsv, n_bcmva, n_lep {
  medium
  tight
  +n_tau, n_pho {
    loose
  }
}

{/F}

! Save two leptons of each kind
muon, ele {
  1, 2 {
    lep(panda::Lepton& lep, unsigned char flag)
      /O = false -> true
      1l_2m_3t/b = 0 -> flag
      q/B = 0 -> lep.charge

      $ -> lep.$() | pt, eta, phi
  }
}

! Some calculated things

"TVector2.h"

{fill(TVector2 recoilvec)}

recoil <- recoilvec.Mod()
recoilphi <- recoilvec.Phi()

dphi_met_trkmet <- deltaPhi(metphi, trkmetphi)

! Input jets are used to set the following variables
"btagreaders.h"
"bcal/BTagCalibrationStandalone.h"
! csv, cmva {
cmva {
  <_jet{1, 2, 3}> {
    bjet(panda::Jet& jet, float maxpt, BCalReaders& readers, BTagEntry::JetFlavor flav, <T> nlep, panda::PFCand* lep)
      maxtrk -> maxpt
      $ -> jet.$ | csv, cmva, deepCSVb, deepCMVAb

      @_sf_$ = 1 -> readers.at(BTagEntry::OP_@@@).eval_auto_bounds("$", flav, <jet.{eta, pt}()>) | central, up, down |@ loose, medium, tight

      ~~ lep ~~

      nlep/b -> nlep
      leadlep_pt -> lep->pt()
      leadlep_ptrel -> lep->p4().Perp(jet.p4().Vect())
      leadlep_dr -> deltaR(<{lep->, jet.}{eta, phi}()>)

    bvert(panda::Ref<panda::SecondaryVertex>& vert)
      ~~ vert.isValid() ~~

      vtx_$ -> vert->$() | pt, m

      vtx_3Dval -> vert->vtx3DVal
      vtx_3Derr -> vert->vtx3DeVal
      vtx_ntrk/s -> vert->ntrk

    +<{, central_}jet{1, 2, 3}> {
      jet(panda::Jet& jet)
        /O = false -> true
        $ -> jet.$() | pt, eta, phi, m, e
        $ -> jet.$ | chf, nhf, cef, nef
        $/O = false -> jet.$ | loose, tight, monojet

        $frac <- <[]_{c + n}$f> | e, h  ! EM and Had Fractions

        qgl -> jet.qgl

      genjet(panda::GenJet& gen, GenNuVec& withnu)
        gen/O = false -> true
        gen_$ -> gen.$() | pt, eta, phi, m
        gen_withnu_$ -> withnu.genvec.$$() | pt, eta, phi, m
        gen_numnu/b = 0 -> withnu.numnu
        gen_tWnu_overlap/O = false -> withnu.overlap

        gen_$/S = 0 -> gen.$ | pdgid, partonFlavor
        gen_$/b = 0 -> gen.$ | numB

    }

    ! Many different regressions to compare!

    [pt_ratio$_@; data/Regression$_@_BDT.weights.xml] = 1 | , _old |@ 3, 15, 40
    [pt_ratio_old_method; data/Regression_old_method_BDT.weights.xml] = 1
    [pt_ratio_old; data/bjet_regression_v0.weights.xml; data/bjet_old_sub.txt] = 1

    ! Need a more systematic name system

    pt_reg$ <- []_pt_ratio$ * []_pt | _old, _old_method
    pt_reg$_@ <- []_pt_ratio$_@ * []_pt | , _old |@ 3, 15, 40

  }

  daughter_$_pt <- std::$(<[]_jet{1, 2}_pt>) | min, max

"TLorentzVector.h"
  _hbb {
    hbb(TLorentzVector& vec)   ! Hbb set by sums of jets as 4-vectors
      /O = false -> true
      $ -> vec.$$() | pt, eta, phi, m

    hbbgen(panda::GenParticle& gen, float dr)
      gen/O = false -> true
      gen_$ -> gen.$() | pt, eta, phi, m

      gen_dr = 10 -> dr

    pt_over_vpt <- []_pt/recoil
  }

  ! Need a more systematic name system

  hbb_m_reg$ <- vectorSumMass(<[]_jet{1, 2}_{pt_reg$, eta, phi, m}>) | _old, _old_method
  hbb_pt_reg$ <- vectorSumPt(<[]_jet{1, 2}_{pt_reg$, phi}>) | _old, _old_method
  hbb_m_reg$_@ <- vectorSumMass(<[]_jet{1, 2}_{pt_reg$_@, eta, phi, m}>) | , _old |@ 3, 15, 40
  hbb_pt_reg$_@ <- vectorSumPt(<[]_jet{1, 2}_{pt_reg$_@, phi}>) | , _old |@ 3, 15, 40

  hbb_reg$_@_over_m <- []_hbb_m_reg$_@/[]_hbb_m | , _old |@ 3, 15, 40
  hbb_reg$_over_m <- []_hbb_m_reg$/[]_hbb_m | _old, _old_method

  $_dijet_m <- vectorSumMass(<[]_jet{1, 2}_$_{pt, eta, phi, m}>) | gen, gen_withnu
  dphi_uh <- deltaPhi([]_hbb_phi, recoilphi)

  daughter_deta <- std::abs([]_jet1_eta - []_jet2_eta)
  daughter_dphi <- deltaPhi(<[]_jet{1, 2}_phi>)
  daughter_dR <- deltaR(<[]_jet{1, 2}_{eta, phi}>)
}

genboson, gen_t, gen_tbar {
  gen(panda::GenParticle& gen)
    /O = false -> true
    $ -> gen.$() | pt, eta, phi, m

    pdgid/I = 0 -> gen.pdgid
}

[event_class_$; data/Classifier_$_BDT.weights.xml] = 0 | m, m_reg_15

! Filter
-- met_filter == 1 and (met > 150 or recoil > 150) and central_jet1_pt > 50 and central_jet2_pt > 25 and cmva_hbb and cmva_jet2_cmva > -0.8 --
