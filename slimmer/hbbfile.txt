"PlotTools/interface/KinematicFunctions.h"
"PandaTree/Objects/interface/Event.h"

{/F}                           ! Default type
{reset(panda::Event& event)}   ! Define the arguments of reset

run_num/I = event.runNumber
lumi_num/I = event.lumiNumber
event_num/l = event.eventNumber

npv/I = event.npv
npv_true/I = event.npvTrue

mc_weight = event.weight

met = event.pfMet.pt
metphi = event.pfMet.phi
calomet = event.caloMet.pt
calometphi = event.caloMet.phi
trkmet = event.trkMet.pt
trkmetphi = event.trkMet.phi

met_trigger/O = false
met_filter/O = event.metFilters.pass()

{/I}
{0}

! Count some objects

n_alljet
n_jet
n_hardjet

n_bcsv, n_bcmva, n_lep {
  medium
  tight
  +n_tau, n_pho {
    loose
  }
}

{/F}
{-5}

! Save two leptons of each kind
muon, ele {
  1, 2 {
    lep(panda::Lepton& lep, unsigned char flag)
      /O = false -> true
      1l_2m_3t/b = 0 -> flag
      q/B = 0 -> lep.charge

      $ -> lep.$() | pt, eta, phi
  }
}

! Some calculated things

"TVector2.h"

{fill(TVector2 recoilvec)}

recoil <- recoilvec.Mod()
recoilphi <- recoilvec.Phi()

dphi_met_trkmet <- deltaPhi(metphi, trkmetphi)

min_dphi_metj_soft = 4
min_dphi_metj_hard = 4

! Input jets are used to set the following variables
"btagreaders.h"
"bcal/BTagCalibrationStandalone.h"
csv, cmva {
  _jet1, _jet2, _jet3 {
    bjet(panda::Jet& jet, float maxpt, BCalReaders& readers, BTagEntry::JetFlavor flav)
      maxtrk -> maxpt
      $ -> jet.$ | csv, cmva, deepCSVb, deepCMVAb

{1}

      @_sf_$ -> readers.at(BTagEntry::OP_@@@).eval_auto_bounds("$", flav, <jet.{eta, pt}()>) | central, up, down |@ loose, medium, tight

{0}    ! Set the defaults for training stuff to 0

    bvert(panda::SecondaryVertex& vert)
      vtx_$ -> vert.$() | pt, m

      vtx_3Dval -> vert.vtx3DVal
      vtx_3Derr -> vert.vtx3DeVal
      vtx_ntrk/I -> vert.ntrk

    bleps(panda::Jet& jet, int nlep, panda::PFCand& lep)
      nlep/I -> nlep
      leadlep_pt -> lep.pt()
      leadlep_ptrel -> lep.p4().Perp(jet.p4().Vect())
      leadlep_dr -> deltaR(<{lep, jet}.{eta, phi}()>)

{-5}

    +jet1, jet2, jet3 {
      jet(panda::Jet& jet)
        /O = false -> true
        $ -> jet.$() | pt, eta, phi, m
        $ -> jet.$ | chf, nhf
        emfrac -> jet.cef + jet.nef

        qgl -> jet.qgl

      genjet(panda::GenJet& gen, TLorentzVector& withnu, unsigned num_nu, bool overlap)
        gen/O = false -> true
        gen_$ -> gen.$() | pt, eta, phi, m
        gen_withnu_$ -> withnu.$$() | pt, eta, phi, m
        gen_numnu/I = 0 -> num_nu
        gen_tWnu_overlap/O = false -> overlap

        gen_$/I = 0 -> gen.$ | pdgid, partonFlavor, numB

    }

    [pt_ratio; data/TMVA_BDT.weights.xml] = 1
    pt_reg <- []_pt_ratio * []_pt

  }
"TLorentzVector.h"
  _hbb {
    hbb(TLorentzVector& vec)   ! Hbb set by sums of jets as 4-vectors
      /O = false -> true
      $ -> vec.$$() | pt, eta, phi, m

    hbbgen(panda::GenParticle& gen, float dr)
      gen/O = false -> true
      gen_$ -> gen.$() | pt, eta, phi, m

      gen_dr = 10 -> dr
  }
  hbb_m_reg <- vectorSumMass(<[]_jet{1, 2}_{pt_reg, eta, phi, m}>)
  $_dijet_m <- vectorSumMass(<[]_jet{1, 2}_$_{pt, eta, phi, m}>) | gen, gen_withnu
  dphi_uh <- deltaPhi([]_hbb_phi, recoilphi)
}

genboson, gen_t, gen_tbar {
  gen(panda::GenParticle& gen)
    /O = false -> true
    $ -> gen.$() | pt, eta, phi, m

    pdgid/I = 0 -> gen.pdgid
}
