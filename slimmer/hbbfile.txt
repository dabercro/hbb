DEFINE REGS 3, 15, 40
! DEFINE REGS 3, 40

<cmath>
<algorithm>
"crombie/KinematicFunctions.h"
"PandaTree/Objects/interface/Event.h"
"misc.h"

{/F}                           ! Default type
{0}                            ! Default value
{reset(panda::Event& event)}   ! Define the arguments of reset

#isData/O = event.isData

$/i = event.$ | runNumber
$ = event.$ | rho
$/l = event.$ | eventNumber, lumiNumber

npv/s = event.npv
npv_true/s = event.npvTrue

mc_weight = event.weight

$@ = event.$@@.pt | pf, calo, trk, raw |@ met
$@phi = event.$@@.phi | pf, calo, trk, raw |@ met

miniaod_pfmet = event.pfMet.pt
miniaod_pfmetphi = event.pfMet.phi

#dztrkmetvec/TVector2 = trkmet::trkmet(event)
dztrkmet <- dztrkmetvec.Mod()
dztrkmetphi <- dztrkmetvec.Phi()

$_trigger/O = false | met, hbb_2016, overlap
met_filter/O = event.metFilters.pass()

countjets(panda::Jet& jet, float abseta, lazy::LazyCuts& cmva, lazy::LazyCuts& csv, lazy::LazyCuts& deepCSV)
  jet_$[] -> jet.$() | pt, eta, phi
  jet_$[] -> jet.$ | cmva, deepCSVb, rawPt
  #? jet_pt[]; jetpt ? -> jet.ptCorr%%

! Count some objects
{/b}

  n_alljet -> ++
  n_allhard -> +(jet_pt[] > 25.0)

  min_dphi_metj_soft/F = 4 -> std::min(min_dphi_metj_soft, static_cast<Float_t>(deltaPhi(pfmetphi, jet.phi())))
  min_dphi_metj_hard/F = 4 -> jet_pt[] > 30.0 ? std::min(min_dphi_metj_hard, static_cast<Float_t>(deltaPhi(pfmetphi, jet.phi()))) : min_dphi_metj_hard

  ~~ abseta < 2.5 ~~

  n_softjet -> ++
  n_jet -> +(jet_pt[] > 30.0)
  n_centerjet -> +(jet_pt[] > 30.0 && abseta < 2.4)
  n_b@_$ -> +(@.$() && abseta < 2.4) | loose, medium, tight |@ cmva, csv, deepCSV

countnopuid(panda::Jet& jet)
  n_nopuid -> ++
  min_dphi_metnopuid/F = 4 -> std::min(min_dphi_metnopuid, static_cast<Float_t>(deltaPhi(pfmetphi, jet.phi())))

n_genB

nB/b
stat2b/b

n_soft {
  , _all, _dylan {
    softcount(float pt)
      $ -> +(pt > $) | 2, 5, 10
      ? $ ; softcount ? -> +(pt * (1.0 +- 0.1) > $) | 2, 5, 10
  }
}

n_pho {
  medium
  tight
  +n_tau {
    loose
  }
}

{/F}

! Save the highest pT of tight lepton
tight_lep_pt

muon, ele {
  lep(panda::Lepton& lep, LepInfo info, lazy::LazyCuts& cuts)

    ~~ cuts.$() ~~ \\ count_$/b -> ++ | presel

    lowreliso/b -> +(info.reliso < 0.4)  ! Both preselected and have low reliso

    #$[] -> info.$ | reliso, minireliso, corrpt
    #q[]/B -> lep.charge

    #pog_$[]/O = false -> lep.$ | loose, medium, tight
    #$[]/O = false -> cuts.$() | loose, medium, tight
    #$[] -> lep.$() | pt, eta, phi

    ~~ cuts.$() ~~ \\ count_$/b -> ++ | loose, medium, tight

  1, 2 {
    dilep(panda::Lepton& lep)
      /O = false -> true
      #$ = -1 -> lep.$() | pt, eta, phi, m
      q/B -> lep.charge
  }
}

di$_m <- vectorSumMass(<${1, 2}_{pt, eta, phi, m}>) | muon, ele
di$_pt <- vectorSumPt(<${1, 2}_{pt, phi}>) | muon, ele


n_lep_$/b <- <{muon + ele}_count_$> | presel, loose, medium, tight
n_$/b <- <{muon + ele}_$> | lowreliso

! Some calculated things

"TVector2.h"

{fill(panda::Event& event, TVector2& recoilvec)}

recoil <- recoilvec.Mod()
recoilphi <- recoilvec.Phi()

! Minimum dphi between MET and b-jet (to be declared)
min_dphi_recoilb <- std::min(<deltaPhi(jet{1, 2}_phi, recoilphi)>)

dphi_met_$met <- deltaPhi(<{pf, $}metphi>) | trk, dztrk

"quickb.h"

bsf(panda::Jet& jet, bool loose)
  ! Hold some values temporarily. Should implement local variables some day

  bjet_$[] -> jet.$() | pt, eta
  #bjet_$[] -> jet.$() | phi
  bjet_$[] -> jet.$ | deepCSVb
  bjet_deepCSV[] -> <jet.deepCSV{b + bb}>
  bjet_$[]/s -> quickb::$(jet) | numB
  #bjet_isloose[]/O -> loose

  n_allbjet/b -> ++

  ~~ not isData ~~

  sf_b_unbin = 1 -> *(quickb::scale_b(jet))
  sf_b_$_bin = 1 -> *(quickb::scale_b_$(jet)) | pt, pt_eta, pt_eta_v2

  (abseta = std::abs(jet.eta()))
  (flavor = btag::flavor(jet))
  (scale = btag::get_scale(jet, flavor))

  ! Stuff for histogram-based scale factors

  #bjet_sf -> scale["central"]
  #? bjet_sf; $ ? -> scale.find("$%%") != scale.end() ? scale["$%%"] : bjet_sf | JES, LF, HF, <{cErr, Stats}{1, 2}>

  btag_sf = 1 -> *(bjet_sf)

  ! BCalibration stuff

  DEFINE BSYST jes, lf, hf, <{hfstats, lfstats, cferr}{1, 2}>

  (nom_sf = btag::cmva_reader.eval_auto_bounds("central", flavor, abseta, <jet.{pt(), cmva}>))
  (nom_sf_2 = btag::deepcsv_reader.eval_auto_bounds("central", flavor, abseta, jet.pt(), <jet.deepCSV{b + bb}>))

  #bcal_sf$ -> nom_sf$ | , _2
  (bsf_eff = btag::eff(<jet.{pt, eta}()>, flavor))

  (tmp_sf_@$ = btag::cmva_reader.eval_auto_bounds("@_$", flavor, abseta, <jet.{pt(), cmva}>)) | BSYST |@ up, down
  (tmp_sf_@$_2 = btag::deepcsv_reader.eval_auto_bounds("@_$", flavor, abseta, jet.pt(), <jet.deepCSV{b + bb}>)) | BSYST |@ up, down

  ! Systematics can be zero sometimes, so we want to evaluate that first
  #? bcal_sf@; $ ? -> (tmp_sf_%$ ? tmp_sf_%$@ : nom_sf) | BSYST |@ , _2

  #bsf_num$ -> +(bcal_sf$ * bsf_eff) | , _2
  #bsf_denom -> +(bsf_eff)

  beff_sf$ <- (bsf_denom ? bsf_num$/bsf_denom : 1.0) | , _2

  bjet_flav[]/b -> flavor
  bjet_sf_3[] -> nom_sf_2
  beff_sf_3 = 1 -> *(nom_sf_2)

! Place these before to drop uncertainties
tag_$ <- eventNumber % 2 ? <jet{1 : 2}_$> | deepCSV, deepCSVb
probe_$ <- eventNumber % 2 ? <jet{2 : 1}_$> | deepCSV, deepCSVb, pt, eta, gen_numB

! Input jets are used to set the following variables
!! <jet{1, 2, 3}> {
<jet{1, 2}> {

! If this is at the top, we don't save all of the systematics from jet pt

DEFINE bkinematics leadlep, vtx, <puppi_{charged, neutral}{, _pu}>, <{em, neut, ch, mu}_r{0..5}>

  @_$frac <- []_@_$/[]_$ | pt, m, e |@ bkinematics
  @_d$ <- TVector2::Phi_mpi_pi([]_@_$ - []_$) | eta, phi |@ bkinematics

  bjet(panda::Jet& jet, float maxtrk, float maxpf, <T> nlep, <P> lep, <C> cuts)

    /O = false -> true
    $ = -1 -> jet.$() | pt, eta, phi, m, e
!    ? pt; jetpt; e, m ? -> jet.ptCorr%%   ! Indicate pt uncertainty

    #p4/TLorentzVector = TLorentzVector() -> [&] () { TLorentzVector p4; p4.SetPtEtaPhiM(<[]_{pt, eta, phi, m}>); return p4; } ()

    $ -> []_p4.$$() | et, mt

    loosepu/O = false -> puid::loose(jet)

    $ -> jet.$ | puid, chf, nhf, cef, nef, ptSmear, rawPt, area

    rawFactor <- []_pt/[]_rawPt

!    ? ptSmear; jetsmear ? -> jet.ptSmear%%

    ! Set the taggers to -2 to disappear them from plots
    $ = -2 -> jet.$ | qgl, csv, cmva, deepCSVb, deepCMVAb
    deepCSV = -2 -> <jet.deepCSV{b + bb}>

    $/O = false -> jet.$ | loose, tight, monojet
    btag$/O = false -> cuts.$ | loose, medium, tight

    $frac <- <[]_{c + n}$f> | e, h  ! EM and Had Fractions

    $ -> $ | <max{trk, pf}>

    !!!!!!!
    ! Regression stuff
    (puppi = regression::GetJetInfo(jet))
    puppi_@_$ -> puppi.@.$$() | pt, m, e |@ <{charged, neutral}{, _pu}>
    puppi_@_$ -> puppi.@.filled ? puppi.@.$$() : []_$ | eta, phi |@ <{charged, neutral}{, _pu}>

    $_r@_energy -> puppi.$_rings[@].first | em, neut, ch, mu |@ 0..5
    @_rX_$ -> puppi.@_rings[X].second.$$() | pt, m, e |@ em, neut, ch, mu |X 0..5
    @_rX_$ -> puppi.@_rings[X].second.filled ? puppi.@_rings[X].second.$$() : []_$ | eta, phi |@ em, neut, ch, mu |X 0..5

    $_r@_rawE_frac <- []_$_r@_energy * []_rawFactor / []_e | em, neut, ch, mu |@ 0..5

    $ -> puppi.$ | ptD
    $/s -> puppi.$ | num03

    pf_@_$ -> puppi.pfinfo[@].$ |@ 0..10 | ptfrac, deta, dphi, puppiwt, dxy, dz
    pf_@_$/I -> puppi.pfinfo[@].$ |@ 0..10 | pdgid
    !!!!!!!

    leadlep_$ -> lep ? lep->$() : []_$ | eta, phi

    ~~ lep ~~

    nlep/b -> nlep
    leadlep_$ -> lep->$() | pt, m, e
    leadlep_ptrel = -1 -> lep->p4().Perp(jet.p4().Vect())
    leadlep_ptrelinv = -1 -> jet.p4().Perp(lep->p4().Vect())
    leadlep_dr = -1 -> deltaR(<{lep->, jet.}{eta, phi}()>)
    leadlep_pdgid/S -> lep->matchedPF.isValid() ? lep->matchedPF->pdgId() : 0
    isEle/O <- std::abs([]_leadlep_pdgid) == 11
    isMu/O <- std::abs([]_leadlep_pdgid) == 13
    isOther/O <- not ([]_isEle or []_isMu)

  bvert(panda::Ref<panda::SecondaryVertex>& vert)
    vtx_$ -> vert.isValid() ? vert->$() : []_$ | eta, phi

    ~~ vert.isValid() ~~

    vtx_$ -> vert->$() | pt, m, e

    vtx_3Dval -> vert->vtx3DVal
    vtx_3Derr -> vert->vtx3DeVal
    vtx_ntrk/s -> vert->ntrk

  ! Some 4-vector info for training

  genjet(panda::GenJet& gen, gennujet::GenNuVec& withnu)

    gen/O = false -> true
    gen_$ -> gen.$() | pt, eta, phi, m
    gen_withnu_$ -> withnu.genvec.$$() | pt, eta, phi, m
    gen_numnu/b -> withnu.numnu
    gen_tWnu_overlap/O = false -> withnu.overlap

    gen_$/S -> gen.$ | pdgid, partonFlavor
    gen_$/b -> gen.$ | numB

  reclustered(fastjet::PseudoJet* jet)

    ~~ jet ~~
    reclustered/O = false -> true
    reclustered_$ -> jet->$() | pt, eta, phi, m

! DEFINE TF_VERS v5, v7, v8, v10, v12
DEFINE TF_VERS 190603_v6, 190604_v0

!  #tf_@/std::vector<float> = {1, 0, 0, 1} \
!      <- lazytf::eval("data/freeze_@.pb", "data/regression2.txt", \
!         {"dnn/logits/BiasAdd"}, 4, \
!         `perl -ane 'chomp; s/jet1/\[\]/; print; eof || print ", "' data/regression2.txt`) |@ v7, v10

!  #tf_@/std::vector<float> = {1, 0, 0, 1} \
!      <- lazytf::eval("data/freeze_@.pb", "data/regression2.txt", \
!         {"dnn/split_logits/Slice"}, 4, \
!         `perl -ane 'chomp; s/jet1/\[\]/; print; eof || print ", "' data/regression2.txt`) |@ v5

!  #tf_@/std::vector<float> = {1, 0, 0, 1} \
!      <- lazytf::eval("data/freeze_@.pb", "data/regression4.txt", \
!         {"dnn/split_logits/Slice"}, 4, \
!         `perl -ane 'chomp; s/jet1/\[\]/g; s/.*=\s*(.*)/$1/; print; eof || print ", "' data/regression4.txt`) |@ v12

!  #tf_@/std::vector<float> = {1, 0, 0, 1} \
!      <- lazytf::eval("data/freeze_@.pb", "data/regression4.txt", \
!         {"dnn/logits/BiasAdd"}, 4, \
!         `perl -ane 'chomp; s/jet1/\[\]/g; s/.*=\s*(.*)/$1/; print; eof || print ", "' data/regression4.txt`) |@ v8

  #tf_@/std::vector<float> = {1} \
      <- lazytf::eval("data/freeze_@.pb", "data/regression7.txt", \
         {"dnn/split_logits/Slice"}, 1, \
         `perl -ane 'chomp; s/jet1/\[\]/; print; eof || print ", "' data/regression7_trns.txt`) |@ 190603_v6

  #tf_@/std::vector<float> = {1} \
      <- lazytf::eval("data/freeze_@.pb", "data/regression6.txt", \
         {"dnn/split_logits/Slice"}, 1, \
         `perl -ane 'chomp; s/jet1/\[\]/; print; eof || print ", "' data/regression6_trns.txt`) |@ 190604_v0

  tf_@_$ <- []_tf_@[=$=] | ptratio |@ TF_VERS
  tf_@_$ = 1 | mratio |@ TF_VERS
  tf_@_$ = 0 | deta, dphi |@ TF_VERS

  [pt_ratio_old; data/TMVARegression_BDT.weights.xml; data/bjet_old_sub.txt] = 1
  [pt_ratio_new; data/Regression_v3_BDT.weights.xml; jet1] = 1

  ! Need a more systematic name system

  pt_reg$ <- []_pt_ratio$ * []_pt | _old, _new ! , _old_method
  $_tf_@ <- []_tf_@_$ratio * []_$ | pt, m |@ TF_VERS
  $_tf_@ <- []_tf_@_d$ + []_$ | eta, phi |@ TF_VERS

}

daughter_$_pt <- std::$(<jet{1, 2}_pt>) | min, max

"TLorentzVector.h"
hbb {
  higgs()

    #vec/TLorentzVector = TLorentzVector() -> vectorSum(<jet{1, 2}_{pt, eta, phi, m}>)
    /O = false -> true
    $ -> []_vec.$$() | pt, eta, phi, m

    m_reg$ <- vectorSumMass(<jet{1, 2}_{pt_reg$, eta, phi, m}>) | _old, _new ! , _old_method
    pt_reg$ <- vectorSumPt(<jet{1, 2}_{pt_reg$, phi}>) | _old, _new ! , _old_method

    m_tf_@ <- vectorSumMass(<jet{1, 2}_{pt, eta, phi, m}_tf_@>) |@ TF_VERS
    pt_tf_@ <- vectorSumPt(<jet{1, 2}_{pt, phi}_tf_@>) |@ TF_VERS

    reg$_over_m <- []_m_reg$/[]_m | _old, _new ! , _old_method

  hbbgen(panda::GenParticle& gen, float dr)
    gen/O = false -> true
    gen_$ -> gen.$() | pt, eta, phi, m

    gen_dr = 10 -> dr

  pt_over_vpt <- []_pt/recoil

}

! Need a more systematic name system

$_dijet_m <- vectorSumMass(<jet{1, 2}_$_{pt, eta, phi, m}>) | gen, gen_withnu, reclustered
dphi_uh <- deltaPhi(hbb_phi, recoilphi)

daughter_deta <- std::abs(jet1_eta - jet2_eta)
daughter_dphi <- deltaPhi(<jet{1, 2}_phi>)
daughter_dR <- deltaR(<jet{1, 2}_{eta, phi}>)

{/b}

countfat(panda::FatJet& jet)

  n_fatjet -> +(jet.pt() > 200)
  ? n_fatjet; jetpt ? -> +(jet.ptCorr%% > 200)

{/F}

! Fat jets are simple for now
ak8 {
  fatjet1 {
    fatjet(panda::FatJet& jet, <T> n_iso, <T> n_iso_b)

      /O = false -> true
      $ -> jet.$() | pt, eta, phi, m, e
      ? pt; jetpt ? -> jet.ptCorr%%
      $/O = false -> jet.$ | loose, tight, monojet
      $ -> jet.$ | mSD, mPruned, <tau{1, 2, 3}{, SD}>

      ! Knock double_sub off of the resolved plots
      $ = -2 -> jet.$ | double_sub

      $/b -> $ | n_iso, n_iso_b

      mSD_corr -> []_mSD * corrections::mSD([]_pt, []_eta)

      #ecf_O_N_B -> jet.ecfs[=O=][=N=][=B=] |O 1..4 |N 1..5 |B p5, 1, 2, 4

      ! This is just used for some filtering
      #good/O = false -> []_pt > 240 and []_mSD_corr > 35

      dphi_u <- deltaPhi([]_phi, recoilphi)
      dR_resolved_hbb <- deltaR(<{[], hbb}_{eta, phi}>)

  }
}

genboson, gen_t, gen_tbar {
  gen(panda::GenParticle& gen)

    /O = false -> true
    $ -> gen.$() | pt, eta, phi, m

    pdgid/I -> gen.pdgid

}

pdf = 1.0

! pandaf/009
!! ? pdf; pdf ? = input::version <= 9 ? 1.0 +- std::abs(event.genReweight.pdfDW) : 1.0

! pandaf/010
pdf_$ = input::version >= 10 ? event.genReweight.pdfAltDW[$] : 1.0 | 0..100

renormfact {
  /F = 1.0
  r$f@DW <- 1.0 + event.genReweight.r$f@DW | 1 |@ 2, 5
  r$f@DW <- 1.0 + event.genReweight.r$f@DW | 2, 5 |@ 1, $
}

[[<tf_class_{no, yes}>; data/classifier_190512.pb; ../analysis/classify3.txt; inputs; out/Softmax]]

! -- genboson_pt > 30 --
! -- jet1_gen_numB --

! Filter
DEFINE BTAGPROBE (n_lep_tight > 0 and n_lep_medium > 1 and (n_centerjet == 2 or n_allbjet == 2))

! These are filled before the fill function
-- \
input::noskim or \
debugevent::debugevent or \
((pfmet > 150 or recoilvec.Mod() > 150) and met_filter) or \
BTAGPROBE
--

! These are filled in the fill function
++ \
input::noskim or \
debugevent::debugevent or \
BTAGPROBE or \
((ak8fatjet1_good and ak8fatjet1_dphi_u > 1.8) or \
 (daughter_max_pt > 40 and daughter_min_pt > 30 and \
  dphi_uh > 1.6 and \
  std::max({<hbb_{pt, pt_reg_new, pt_reg_old}>}) > 100) and \
   ((n_lep_presel == 0 and min_dphi_metj_hard > 0.25) or \
    (n_lep_loose > 0 and n_centerjet >= 4)\
   )\
) \
++


!!!!!!!! Scale factors !!!!!!!!


DEFINE HTCUT input::isHT and std::abs(genboson_pdgid) == 23 + =$=
DEFINE KFACTORS genboson_pt; data/kfactors.root

sf_tt <- gen_t and gen_tbar ? std::sqrt(std::exp(0.0615-0.0005*std::min(400.0f, gen_t_pt)) * std::exp(0.0615-0.0005 * std::min(400.0f, gen_tbar_pt))) : 1.0

! I have a bug in my reweighting script which is attempting to normalize things
sf_met_trigger = input::version == 10 ? 1.0/0.000670411 : 1.0
~ sf_met_trigger; pfmet; data/metTriggerEfficiency_recoil_monojet_TH1F.root; hden_monojet_recoil_clone_passed ~
~ sf_met_trigger; recoil; data/met2016to2017.root; mettrig; input::version == 10 ~

~ sf_met_trigger_2; recoil; data/met_trigger_effs_2018.root; eff ~

! Set the name of the merged corrections
~{scale_factors <- mc_weight * sf_tt * sf_met_trigger}~

~ sf_pu; npv_true; $; puWeights; input::version <= 9 + =$= ~ | <data/puWeights_{80x_37ifb, 90x}.root>
~ sf_pu; npv_true; data/puWeights_10x_56ifb.root; puWeights; input::version == 13 ~

~ ewk_$; KFACTORS; EWKcorr/$$, $$Jets_012j_NLO/nominal; HTCUT ~ | z, w
~ $kfactor; KFACTORS; $$Jets_012j_NLO/nominal, $$Jets_LO/inv_pt; HTCUT ~ | z, w
?~ $kfactor_$@%%; KFACTORS; $$Jets_012j_NLO/@_%, $$Jets_LO/inv_pt ; HTCUT ~ | z, w |@ fact, ren |% up, down

DEFINE HFILE genboson_pt; data/$_nloEWK_weight_unnormalized.root
DEFINE HCUT input::is$ and std::abs(genboson_pdgid) ==

DEFINE HNOM vh_ewk; HFILE; SignalWeight_nloEWK_rebin; HCUT

~ HNOM 24 ~ | Wm, Wp
~ HNOM 23 ~ | Zll, Znn

DEFINE HUNC vh_ewk_ewk%%; HFILE; SignalWeight_nloEWK_%_rebin; HCUT

?~ HUNC 24 ~ | Wm, Wp |% up, down
?~ HUNC 25 ~ | Zll, Znn |% up, down
