DEFINE REGS 3, 15, 40
! DEFINE REGS 3, 40

<cmath>
<algorithm>
"PlotTools/interface/KinematicFunctions.h"
"PandaTree/Objects/interface/Event.h"
"misc.h"

{/F}                           ! Default type
{0}                            ! Default value
{reset(panda::Event& event)}   ! Define the arguments of reset

$/i = event.$ | runNumber, lumiNumber
eventNumber/l = event.eventNumber

npv/s = event.npv
npv_true/s = event.npvTrue

mc_weight = event.weight

$@ = event.$@@.pt | pf, calo, trk |@ met
$@phi = event.$@@.phi | pf, calo, trk |@ met

met_trigger/O = false
met_filter/O = event.metFilters.pass()

countjets(panda::Jet& jet, float abseta, lazy::LazyCuts& cmva, lazy::LazyCuts& csv)
  jet_$[] -> jet.$() | pt, eta, phi
  ? jet_pt[]; jetpt ? -> jet.ptCorr%%

! Count some objects
{/b}

  n_alljet -> ++
  n_allhard -> +(jet_pt[] > 30.0)

  ~~ abseta < 2.5 ~~

  n_softjet -> ++
  n_jet -> +(jet_pt[] > 30.0)
  n_centerjet -> +(jet_pt[] > 30.0 && abseta < 2.4)
  n_b@_$ -> +(@.$() && jet_pt[] > 25.0 && abseta < 2.4) | loose, medium, tight |@ cmva, csv

  min_dphi_metj_soft/F = 4 -> std::min(min_dphi_metj_soft, static_cast<Float_t>(deltaPhi(pfmetphi, jet.phi())));

  ~~ jet.pt() > 30.0 ~~
  min_dphi_metj_hard/F = 4 -> std::min(min_dphi_metj_hard, static_cast<Float_t>(deltaPhi(pfmetphi, jet.phi())));

n_genB

n_soft {
  , _all {
    softcount(float pt)
      $ -> +(pt > $) | 2, 5, 10
      ? $ ; softcount ? -> +(pt * (1.0 +- 0.1) > $) | 2, 5, 10
  }
}

n_pho {
  medium
  tight
  +n_tau {
    loose
  }
}

{/F}

! Save the highest pT of tight lepton
tight_lep_pt

muon, ele {
  lep(panda::Lepton& lep, LepInfo info, lazy::LazyCuts& cuts)
    ! Don't save the rest of the stuff for anything that's not loose
    ! but count presel here
    ~~ cuts.$() ~~ \\ count_$/b -> ++ | presel, loose

    $[] -> info.$ | reliso, corrpt
    q[]/B -> lep.charge

    pog_$[]/O = false -> lep.$ | loose, medium, tight
    $[]/O = false -> cuts.$() | loose, medium, tight
    $[] -> lep.$() | pt, eta

    ~~ cuts.$() ~~ \\ count_$/b -> ++ | medium, tight
}

n_lep_$/b <- <{muon + ele}_count_$> | presel, loose, medium, tight

! Some calculated things

"TVector2.h"

{fill(TVector2 recoilvec)}

recoil <- recoilvec.Mod()
recoilphi <- recoilvec.Phi()

! Minimum dphi between MET and b-jet (to be declared)
min_dphi_recoilb <- std::min(<deltaPhi(cmva_jet{1, 2}_phi, recoilphi)>)

dphi_met_trkmet <- deltaPhi(<{pf, trk}metphi>)

bsf(panda::Jet& jet)
  ! Hold some values temporarily. Should implement local variables some day
  (flavor = btag::flavor(jet.matchedGenJet))
  (nom_sf = btag::cmva_reader.eval_auto_bounds("central", flavor, <jet.{eta(), pt(), cmva}>))

  n_allbjet/b -> ++

  bjet_$[] -> jet.$() | pt, eta
  #bjet_$[] -> jet.$() | phi
  bjet_$[] -> jet.$ | cmva

  ? bjet_pt[] ; jetpt ? -> jet.ptCorr%%
  bjet_sf[] -> nom_sf

  bsf_eff -> btag::eff(<bjet_{pt, eta}[]>, flavor)

DEFINE BSYST jes, lf, hf, <{hfstats, lfstats, cferr}{1, 2}>

  (tmp_sf_@$ = btag::cmva_reader.eval_auto_bounds("@_$", flavor, <jet.{eta(), pt(), cmva}>)) | BSYST |@ up, down


  ! Systematics can be zero sometimes, so we want to evaluate that first
  ? bjet_sf[]; $ ? -> (tmp_sf_%$ ? tmp_sf_%$ : nom_sf) | BSYST

  btag_sf = 1 -> *(bjet_sf[])

  bsf_num -> +(bjet_sf[] * bsf_eff)
  bsf_denom -> +(bsf_eff)

  beff_sf <- (bsf_denom ? bsf_num/bsf_denom : 1.0)

! Input jets are used to set the following variables
cmva {
  <_jet{1, 2, 3}> {
    bjet(panda::Jet& jet, float maxpt, <T> nlep, panda::PFCand* lep)

      /O = false -> true
      $ -> jet.$() | pt, eta, phi, m, e
      ? pt; jetpt; e, m ? -> jet.ptCorr%%   ! Indicate pt uncertainty

      $ -> jet.$ | puid, chf, nhf, cef, nef, ptSmear

      ? ptSmear; jetsmear ? -> jet.ptSmear%%

      ! Set the taggers to -2 to disappear them from plots
      $ = -2 -> jet.$ | qgl, csv, cmva, deepCSVb, deepCMVAb

      $/O = false -> jet.$ | loose, tight, monojet

      $frac <- <[]_{c + n}$f> | e, h  ! EM and Had Fractions

      (flav = btag::flavor(jet.matchedGenJet))
      maxtrk -> maxpt

      sf = 1 -> btag::cmva_reader.eval_auto_bounds("central", flav, <[]_{eta, pt, cmva}>)

      sf_@ = 1 -> btag::cmva_readers.at(BTagEntry::OP_@@@).eval_auto_bounds("central", flav, <[]_{eta, pt, cmva}>) |@ loose, medium, tight
      ? sf_@; btagsf ? = 1 -> btag::cmva_readers.at(BTagEntry::OP_@@@).eval_auto_bounds("%", flav, <[]_{eta, pt, cmva}>) |@ loose, medium, tight

      ~~ lep ~~

      nlep/b -> nlep
      leadlep_pt -> lep->pt()
      leadlep_ptrel -> lep->p4().Perp(jet.p4().Vect())
      leadlep_dr -> deltaR(<{lep->, jet.}{eta, phi}()>)

    bvert(panda::Ref<panda::SecondaryVertex>& vert)
      ~~ vert.isValid() ~~

      vtx_$ -> vert->$() | pt, m

      vtx_3Dval -> vert->vtx3DVal
      vtx_3Derr -> vert->vtx3DeVal
      vtx_ntrk/s -> vert->ntrk

    genjet(panda::GenJet& gen, GenNuVec& withnu)
      gen/O = false -> true
      gen_$ -> gen.$() | pt, eta, phi, m
      gen_withnu_$ -> withnu.genvec.$$() | pt, eta, phi, m
      gen_numnu/b -> withnu.numnu
      gen_tWnu_overlap/O = false -> withnu.overlap

      gen_$/S -> gen.$ | pdgid, partonFlavor
      gen_$/b -> gen.$ | numB

    ! Many different regressions to compare!

    [pt_ratio$_@; data/Regression$_@_BDT.weights.xml] = 1 | , _old |@ REGS
    [pt_ratio_old_method; data/Regression_old_method_BDT.weights.xml] = 1
    [pt_ratio_old; data/bjet_regression_v0.weights.xml; data/bjet_old_sub.txt] = 1
    [pt_ratio_smeared; data/Regression_smeared_BDT.weights.xml] = 1

    ! Need a more systematic name system

    pt_reg$ <- []_pt_ratio$ * []_pt | _old, _old_method
    pt_reg$_@ <- []_pt_ratio$_@ * []_pt | , _old |@ REGS
  }

  daughter_$_pt <- std::$(<[]_jet{1, 2}_pt>) | min, max

"TLorentzVector.h"
  _hbb {
    hbb()
      #vec/TLorentzVector = TLorentzVector() -> vectorSum(<[^]_jet{1, 2}_{pt, eta, phi, m}>)
      /O = false -> true
      $ -> []_vec.$$() | pt, eta, phi, m

      m_reg$ <- vectorSumMass(<[^]_jet{1, 2}_{pt_reg$, eta, phi, m}>) | _old, _old_method
      pt_reg$ <- vectorSumPt(<[^]_jet{1, 2}_{pt_reg$, phi}>) | _old, _old_method
      m_reg$_@ <- vectorSumMass(<[^]_jet{1, 2}_{pt_reg$_@, eta, phi, m}>) | , _old |@ REGS
      pt_reg$_@ <- vectorSumPt(<[^]_jet{1, 2}_{pt_reg$_@, phi}>) | , _old |@ REGS

      reg$_@_over_m <- []_m_reg$_@/[]_m | , _old |@ REGS
      reg$_over_m <- []_m_reg$/[]_m | _old, _old_method

    hbbgen(panda::GenParticle& gen, float dr)
      gen/O = false -> true
      gen_$ -> gen.$() | pt, eta, phi, m

      gen_dr = 10 -> dr

    pt_over_vpt <- []_pt/recoil
  }

  ! Need a more systematic name system

  $_dijet_m <- vectorSumMass(<[]_jet{1, 2}_$_{pt, eta, phi, m}>) | gen, gen_withnu
  dphi_uh <- deltaPhi([]_hbb_phi, recoilphi)

  daughter_deta <- std::abs([]_jet1_eta - []_jet2_eta)
  daughter_dphi <- deltaPhi(<[]_jet{1, 2}_phi>)
  daughter_dR <- deltaR(<[]_jet{1, 2}_{eta, phi}>)
}

{/b}

countfat(panda::FatJet& jet)
  n_fatjet -> +(jet.pt() > 200)
  ? n_fatjet; jetpt ? -> +(jet.ptCorr%% > 200)

{/F}

! Fat jets are simple for now
ak8, ca15 {
  fatjet1 {
    fatjet(panda::FatJet& jet, <T> n_iso, <T> n_iso_b)
      /O = false -> true
      $ -> jet.$() | pt, eta, phi, m, e
      ? pt; jetpt ? -> jet.ptCorr%%
      $/O = false -> jet.$ | loose, tight, monojet
      $ -> jet.$ | mSD, mPruned, <tau{1, 2, 3}{, SD}>

      ! Knock double_sub off of the resolved plots
      $ = -2 -> jet.$ | double_sub

      $/b -> $ | n_iso, n_iso_b

      mSD_corr -> []_mSD * corrections::mSD([]_pt, []_eta)

      ! This is just used for some filtering
      #good/O = false -> []_pt > 220 and []_mSD_corr > 25

      dphi_u <- deltaPhi([]_phi, recoilphi)
      dR_resolved_hbb <- deltaR(<{[], cmva_hbb}_{eta, phi}>)
  }
}

genboson, gen_t, gen_tbar {
  gen(panda::GenParticle& gen)
    /O = false -> true
    $ -> gen.$() | pt, eta, phi, m

    pdgid/I -> gen.pdgid
}

pdf = 1.0
? pdf; pdf ? = 1.0 +- std::abs(event.genReweight.pdfDW)

r$f@DW = event.genReweight.r$f@DW | 1 |@ 2, 5
r$f@DW = event.genReweight.r$f@DW | 2, 5 |@ 1, $

[event_class$; data/Classifier_m$_BDT.weights.xml] | , _reg_3, _reg_40
[boost_class; data/Classifier_wboost_BDT.weights.xml; data/boosted_sub.txt]


! Filter
! These are filled before the fill function
-- debug::debugevent or (met_filter == 1 and (pfmet > 150 or recoilvec.Mod() > 150) and (min_dphi_metj_hard > 0.5 or n_jet >= 4)) --
! These are filled in the fill function
++ debug::debugevent or ((ak8fatjet1 or ca15fatjet1 or (cmva_daughter_max_pt > 50 and cmva_daughter_min_pt > 25)) and (n_lep_presel == 0 or n_lep_tight > 0)) ++
