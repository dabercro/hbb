"PlotTools/interface/KinematicFunctions.h"
"PandaTree/Objects/interface/Event.h"

{/F}                           ! Default type
{reset(panda::Event& event)}   ! Define the arguments of reset

run_num/I = event.runNumber
lumi_num/I = event.lumiNumber
event_num/l = event.eventNumber

npv/I = event.npv
npv_true/I = event.npvTrue

mc_weight = event.weight

met = event.pfMet.pt
metphi = event.pfMet.phi
calomet = event.caloMet.pt
calometphi = event.caloMet.phi
trkmet = event.trkMet.pt
trkmetphi = event.trkMet.phi

met_trigger/O = false
met_filter/O = event.metFilters.pass()

{/I}
{0}

! Count some objects

n_alljet
n_jet
n_hardjet

n_genB

n_bcsv, n_bcmva, n_lep {
  medium
  tight
  +n_tau, n_pho {
    loose
  }
}

{/F}
{-5}

! Save two leptons of each kind
muon, ele {
  1, 2 {
    lep(panda::Lepton& lep, unsigned char flag)
      /O = false -> true
      1l_2m_3t/b = 0 -> flag
      q/B = 0 -> lep.charge

      $ -> lep.$() | pt, eta, phi
  }
}

! Some calculated things

"TVector2.h"

{fill(TVector2 recoilvec)}

recoil <- recoilvec.Mod()
recoilphi <- recoilvec.Phi()

dphi_met_trkmet <- deltaPhi(metphi, trkmetphi)

min_dphi_metj_soft = 4
min_dphi_metj_hard = 4

! Input jets are used to set the following variables
"btagreaders.h"
"bcal/BTagCalibrationStandalone.h"
! csv, cmva {
cmva {
  <_jet{1, 2, 3}> {
    bjet(panda::Jet& jet, float maxpt, BCalReaders& readers, BTagEntry::JetFlavor flav)
      maxtrk -> maxpt
      $ -> jet.$ | csv, cmva, deepCSVb, deepCMVAb

{1}

      @_sf_$ -> readers.at(BTagEntry::OP_@@@).eval_auto_bounds("$", flav, <jet.{eta, pt}()>) | central, up, down |@ loose, medium, tight

{0}    ! Set the defaults for training stuff to 0

    bvert(panda::SecondaryVertex& vert)
      vtx_$ -> vert.$() | pt, m

      vtx_3Dval -> vert.vtx3DVal
      vtx_3Derr -> vert.vtx3DeVal
      vtx_ntrk/I -> vert.ntrk

    bleps(panda::Jet& jet, int nlep, panda::PFCand& lep)
      nlep/I -> nlep
      leadlep_pt -> lep.pt()
      leadlep_ptrel -> lep.p4().Perp(jet.p4().Vect())
      leadlep_dr -> deltaR(<{lep, jet}.{eta, phi}()>)

{-5}

    +<jet{1, 2, 3}> {
      jet(panda::Jet& jet)
        /O = false -> true
        $ -> jet.$() | pt, eta, phi, m, e
        $ -> jet.$ | chf, nhf, cef, nef
        $/O = false -> jet.$ | loose, tight, monojet
        $frac -> jet.c$f + jet.n$f | e, h  ! EM and Had Fractions

        qgl -> jet.qgl

      genjet(panda::GenJet& gen, TLorentzVector& withnu, unsigned num_nu, bool overlap)
        gen/O = false -> true
        gen_$ -> gen.$() | pt, eta, phi, m
        gen_withnu_$ -> withnu.$$() | pt, eta, phi, m
        gen_numnu/I = 0 -> num_nu
        gen_tWnu_overlap/O = false -> overlap

        gen_$/I = 0 -> gen.$ | pdgid, partonFlavor, numB

    }

    #[pt_ratio; data/Regression_BDT.weights.xml] = 1
    #[pt_ratio_old; data/bjet_regression_v0.weights.xml; data/bjet_old_sub.txt] = 1
    pt_reg$ <- []_pt_ratio$ * []_pt | , _old

  }

"TLorentzVector.h"
  _hbb {
    hbb(TLorentzVector& vec)   ! Hbb set by sums of jets as 4-vectors
      /O = false -> true
      $ -> vec.$$() | pt, eta, phi, m

    hbbgen(panda::GenParticle& gen, float dr)
      gen/O = false -> true
      gen_$ -> gen.$() | pt, eta, phi, m

      gen_dr = 10 -> dr

    pt_over_vpt <- []_pt/recoil
  }
  hbb_m_reg$ <- vectorSumMass(<[]_jet{1, 2}_{pt_reg$, eta, phi, m}>) | , _old
  hbb_pt_reg$ <- vectorSumPt(<[]_jet{1, 2}_{pt_reg$, phi}>) | , _old

  hbb_reg$_over_m <- []_hbb_m_reg$/[]_hbb_m | , _old

  $_dijet_m <- vectorSumMass(<[]_jet{1, 2}_$_{pt, eta, phi, m}>) | gen, gen_withnu
  dphi_uh <- deltaPhi([]_hbb_phi, recoilphi)

  daughter_deta <- fabs([]_jet1_eta - []_jet2_eta)
  daughter_dphi <- deltaPhi(<[]_jet{1, 2}_phi>)
  daughter_dR <- deltaR(<[]_jet{1, 2}_{eta, phi}>)
}

genboson, gen_t, gen_tbar {
  gen(panda::GenParticle& gen)
    /O = false -> true
    $ -> gen.$() | pt, eta, phi, m

    pdgid/I = 0 -> gen.pdgid
}

#[event_class; data/Classifier_BDT.weights.xml] = 0

! Filter
! -- met_filter == 1 and (met > 150 or recoil > 150) and jet1_pt > 30 and cmva_hbb --
